name: Documentation Feedback Processing

on:
  issues:
    types: [opened, closed, labeled, unlabeled]
  issue_comment:
    types: [created, edited]
  schedule:
    # Run daily at 9 AM UTC to process feedback
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'process'
        type: choice
        options:
          - process
          - report
          - cleanup

jobs:
  process-feedback:
    runs-on: ubuntu-latest
    name: Process Documentation Feedback
    if: contains(github.event.issue.labels.*.name, 'documentation-feedback') || github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Get feedback issues
        id: feedback-issues
        uses: actions/github-script@v6
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'documentation-feedback',
              state: 'open',
              sort: 'created',
              direction: 'desc'
            });
            
            return issues.map(issue => ({
              number: issue.number,
              title: issue.title,
              body: issue.body,
              created_at: issue.created_at,
              updated_at: issue.updated_at,
              labels: issue.labels.map(label => label.name),
              assignee: issue.assignee?.login,
              comments: issue.comments
            }));
            
      - name: Analyze feedback
        id: feedback-analysis
        run: |
          echo "ðŸ“Š Analyzing documentation feedback..."
          
          # Get feedback issues
          issues='${{ steps.feedback-issues.outputs.result }}'
          
          # Initialize counters
          total_issues=0
          new_issues=0
          in_progress_issues=0
          high_priority_issues=0
          
          # Initialize category counters
          content_quality=0
          organization=0
          examples=0
          missing_info=0
          technical_accuracy=0
          usability=0
          other=0
          
          # Initialize satisfaction counters
          very_satisfied=0
          satisfied=0
          neutral=0
          dissatisfied=0
          very_dissatisfied=0
          
          # Process each issue
          echo "$issues" | jq -r '.[] | @base64' | while read -r issue; do
            issue_data=$(echo "$issue" | base64 -d)
            
            # Count total issues
            total_issues=$((total_issues + 1))
            
            # Check status
            if echo "$issue_data" | jq -e '.labels | contains(["new"])' > /dev/null; then
              new_issues=$((new_issues + 1))
            elif echo "$issue_data" | jq -e '.labels | contains(["in-progress"])' > /dev/null; then
              in_progress_issues=$((in_progress_issues + 1))
            fi
            
            # Check priority
            if echo "$issue_data" | jq -e '.labels | contains(["high-priority"])' > /dev/null; then
              high_priority_issues=$((high_priority_issues + 1))
            fi
            
            # Extract feedback type
            if echo "$issue_data" | jq -e '.body | contains("Content Quality")' > /dev/null; then
              content_quality=$((content_quality + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Organization/Structure")' > /dev/null; then
              organization=$((organization + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Examples/Tutorials")' > /dev/null; then
              examples=$((examples + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Missing Information")' > /dev/null; then
              missing_info=$((missing_info + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Technical Accuracy")' > /dev/null; then
              technical_accuracy=$((technical_accuracy + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Usability")' > /dev/null; then
              usability=$((usability + 1))
            else
              other=$((other + 1))
            fi
            
            # Extract satisfaction rating
            if echo "$issue_data" | jq -e '.body | contains("Very Satisfied (5)")' > /dev/null; then
              very_satisfied=$((very_satisfied + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Satisfied (4)")' > /dev/null; then
              satisfied=$((satisfied + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Neutral (3)")' > /dev/null; then
              neutral=$((neutral + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Dissatisfied (2)")' > /dev/null; then
              dissatisfied=$((dissatisfied + 1))
            elif echo "$issue_data" | jq -e '.body | contains("Very Dissatisfied (1)")' > /dev/null; then
              very_dissatisfied=$((very_dissatisfied + 1))
            fi
          done
          
          # Calculate average satisfaction
          total_ratings=$((very_satisfied + satisfied + neutral + dissatisfied + very_dissatisfied))
          if [ $total_ratings -gt 0 ]; then
            satisfaction_score=$(( (very_satisfied * 5 + satisfied * 4 + neutral * 3 + dissatisfied * 2 + very_dissatisfied * 1) / total_ratings ))
          else
            satisfaction_score=0
          fi
          
          # Output results
          echo "total_issues=$total_issues" >> $GITHUB_OUTPUT
          echo "new_issues=$new_issues" >> $GITHUB_OUTPUT
          echo "in_progress_issues=$in_progress_issues" >> $GITHUB_OUTPUT
          echo "high_priority_issues=$high_priority_issues" >> $GITHUB_OUTPUT
          echo "content_quality=$content_quality" >> $GITHUB_OUTPUT
          echo "organization=$organization" >> $GITHUB_OUTPUT
          echo "examples=$examples" >> $GITHUB_OUTPUT
          echo "missing_info=$missing_info" >> $GITHUB_OUTPUT
          echo "technical_accuracy=$technical_accuracy" >> $GITHUB_OUTPUT
          echo "usability=$usability" >> $GITHUB_OUTPUT
          echo "other=$other" >> $GITHUB_OUTPUT
          echo "very_satisfied=$very_satisfied" >> $GITHUB_OUTPUT
          echo "satisfied=$satisfied" >> $GITHUB_OUTPUT
          echo "neutral=$neutral" >> $GITHUB_OUTPUT
          echo "dissatisfied=$dissatisfied" >> $GITHUB_OUTPUT
          echo "very_dissatisfied=$very_dissatisfied" >> $GITHUB_OUTPUT
          echo "satisfaction_score=$satisfaction_score" >> $GITHUB_OUTPUT
          
          echo "âœ… Feedback analysis completed"
          
      - name: Triage new feedback
        if: steps.feedback-analysis.outputs.new_issues > 0
        uses: actions/github-script@v6
        with:
          script: |
            const issues = '${{ steps.feedback-issues.outputs.result }}';
            const issueData = JSON.parse(issues);
            
            for (const issue of issueData) {
              // Check if issue is new (no status labels)
              const hasStatusLabel = issue.labels.some(label => 
                ['new', 'in-progress', 'resolved', 'closed'].includes(label)
              );
              
              if (!hasStatusLabel) {
                // Add 'new' label
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['new']
                });
                
                // Check if high priority
                const isHighPriority = issue.body.includes('Critical') || 
                                     issue.body.includes('High Priority') ||
                                     issue.labels.includes('bug');
                
                if (isHighPriority) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['high-priority']
                  });
                  
                  // Assign to documentation team
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    assignees: ['clms-documentation-team']
                  });
                  
                  // Create notification comment
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `ðŸš¨ **High Priority Feedback**\n\nThis feedback has been marked as high priority and assigned to the documentation team for immediate review.\n\n**Next Steps**:\n- [ ] Review feedback details\n- [ ] Assess impact and urgency\n- [ ] Create action plan\n- [ ] Implement improvements\n\n**Target Resolution**: Within 7 days`
                  });
                } else {
                  // Assign to documentation team for regular review
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    assignees: ['clms-documentation-team']
                  });
                  
                  // Create acknowledgment comment
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `ðŸ“ **Feedback Received**\n\nThank you for your feedback! This has been received and will be reviewed by the documentation team.\n\n**Review Process**:\n- [ ] Initial triage and categorization\n- [ ] Priority assessment\n- [ ] Action plan creation\n- [ ] Implementation of improvements\n\n**Target Resolution**: Within 30 days`
                  });
                }
              }
            }
            
      - name: Generate feedback report
        run: |
          echo "ðŸ“Š Generating feedback report..."
          
          # Get analysis results
          total_issues="${{ steps.feedback-analysis.outputs.total_issues }}"
          new_issues="${{ steps.feedback-analysis.outputs.new_issues }}"
          in_progress_issues="${{ steps.feedback-analysis.outputs.in_progress_issues }}"
          high_priority_issues="${{ steps.feedback-analysis.outputs.high_priority_issues }}"
          satisfaction_score="${{ steps.feedback-analysis.outputs.satisfaction_score }}"
          
          # Create feedback report
          cat > feedback-report.md << EOF
          # Documentation Feedback Report
          
          **Generated**: $(date -u +"%Y-%m-%dT%H:%M:%SZ")  
          **Period**: Last 30 days  
          **Total Issues**: $total_issues
          
          ## ðŸ“Š Summary
          
          ### Issue Status
          - **New Issues**: $new_issues
          - **In Progress**: $in_progress_issues
          - **High Priority**: $high_priority_issues
          
          ### Satisfaction Score
          - **Average Rating**: $satisfaction_score/5
          - **Total Ratings**: $((very_satisfied + satisfied + neutral + dissatisfied + very_dissatisfied))
          
          ### Feedback Categories
          - **Content Quality**: ${{ steps.feedback-analysis.outputs.content_quality }}
          - **Organization/Structure**: ${{ steps.feedback-analysis.outputs.organization }}
          - **Examples/Tutorials**: ${{ steps.feedback-analysis.outputs.examples }}
          - **Missing Information**: ${{ steps.feedback-analysis.outputs.missing_info }}
          - **Technical Accuracy**: ${{ steps.feedback-analysis.outputs.technical_accuracy }}
          - **Usability**: ${{ steps.feedback-analysis.outputs.usability }}
          - **Other**: ${{ steps.feedback-analysis.outputs.other }}
          
          ### Satisfaction Breakdown
          - **Very Satisfied (5)**: ${{ steps.feedback-analysis.outputs.very_satisfied }}
          - **Satisfied (4)**: ${{ steps.feedback-analysis.outputs.satisfied }}
          - **Neutral (3)**: ${{ steps.feedback-analysis.outputs.neutral }}
          - **Dissatisfied (2)**: ${{ steps.feedback-analysis.outputs.dissatisfied }}
          - **Very Dissatisfied (1)**: ${{ steps.feedback-analysis.outputs.very_dissatisfied }}
          
          ## ðŸŽ¯ Key Insights
          
          ### Top Issues
          1. **Most Common Category**: $(echo "${{
            steps.feedback-analysis.outputs.content_quality
          }} ${{ steps.feedback-analysis.outputs.organization
          }} ${{ steps.feedback-analysis.outputs.examples
          }} ${{ steps.feedback-analysis.outputs.missing_info
          }} ${{ steps.feedback-analysis.outputs.technical_accuracy
          }} ${{ steps.feedback-analysis.outputs.usability
          }}" | tr ' ' '\n' | sort -nr | head -1)
          
          2. **Priority Issues**: $high_priority_issues issues requiring immediate attention
          
          3. **Satisfaction Trend**: $([ $satisfaction_score -ge 4 ] && echo "Excellent" || [ $satisfaction_score -ge 3 ] && echo "Good" || echo "Needs Improvement")
          
          ### Recommendations
          EOF
          
          # Add recommendations based on analysis
          if [ "${{ steps.feedback-analysis.outputs.missing_info }}" -gt 0 ]; then
            echo "- **Add Missing Content**: Focus on completing documentation gaps" >> feedback-report.md
          fi
          
          if [ "${{ steps.feedback-analysis.outputs.examples }}" -gt 0 ]; then
            echo "- **Improve Examples**: Add more examples and tutorials" >> feedback-report.md
          fi
          
          if [ "${{ steps.feedback-analysis.outputs.usability }}" -gt 0 ]; then
            echo "- **Enhance Usability**: Improve navigation and organization" >> feedback-report.md
          fi
          
          if [ "${{ steps.feedback-analysis.outputs.technical_accuracy }}" -gt 0 ]; then
            echo "- **Verify Technical Accuracy**: Review and update technical content" >> feedback-report.md
          fi
          
          if [ $satisfaction_score -lt 3 ]; then
            echo "- **Address Low Satisfaction**: Investigate and resolve major issues" >> feedback-report.md
          fi
          
          echo "" >> feedback-report.md
          echo "## ðŸ“ˆ Action Items" >> feedback-report.md
          echo "" >> feedback-report.md
          echo "- [ ] Review high-priority issues" >> feedback-report.md
          echo "- [ ] Update content based on feedback" >> feedback-report.md
          echo "- [ ] Improve examples and tutorials" >> feedback-report.md
          echo "- [ ] Enhance navigation and organization" >> feedback-report.md
          echo "- [ ] Verify technical accuracy" >> feedback-report.md
          echo "" >> feedback-report.md
          echo "---" >> feedback-report.md
          echo "" >> feedback-report.md
          echo "*This report was automatically generated*" >> feedback-report.md
          
          echo "âœ… Feedback report generated"
          
      - name: Create feedback report issue
        if: github.event_name == 'schedule' || github.event.inputs.action == 'report'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // Read feedback report
            const report = fs.readFileSync('feedback-report.md', 'utf8');
            
            // Create or update monthly report issue
            const month = new Date().toISOString().slice(0, 7); // YYYY-MM
            const title = `Documentation Feedback Report - ${month}`;
            
            // Check if issue already exists
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'feedback-report'
            });
            
            const existingIssue = issues.find(issue => issue.title.includes(month));
            
            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: report
              });
              
              console.log(`Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: report,
                labels: ['feedback-report', 'monthly-report']
              });
              
              console.log(`Created new issue #${issue.data.number}`);
            }
            
      - name: Upload feedback report
        uses: actions/upload-artifact@v3
        with:
          name: feedback-report
          path: feedback-report.md
          retention-days: 30
          
      - name: Notify team of high-priority issues
        if: steps.feedback-analysis.outputs.high_priority_issues > 0
        uses: actions/github-script@v6
        with:
          script: |
            const highPriorityCount = '${{ steps.feedback-analysis.outputs.high_priority_issues }}';
            
            if (highPriorityCount > 0) {
              // Create notification in documentation team
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ðŸš¨ High Priority Documentation Feedback Alert`,
                body: `## High Priority Feedback Alert\n\n**Date**: ${new Date().toISOString()}\n**Count**: ${highPriorityCount} high-priority issues\n\n**Action Required**: Please review and address high-priority documentation feedback as soon as possible.\n\n**Next Steps**:\n1. Review high-priority issues\n2. Assess impact and urgency\n3. Create action plans\n4. Implement improvements\n\n**Target Resolution**: Within 7 days\n\n---\n\n*This alert was automatically generated*`,
                labels: ['alert', 'high-priority', 'documentation']
              });
            }

  cleanup-old-issues:
    runs-on: ubuntu-latest
    name: Cleanup Old Feedback Issues
    if: github.event_name == 'schedule' || github.event.inputs.action == 'cleanup'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Find old resolved issues
        id: old-issues
        uses: actions/github-script@v6
        with:
          script: |
            // Find issues closed more than 90 days ago
            const ninetyDaysAgo = new Date();
            ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
            
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'documentation-feedback',
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });
            
            const oldIssues = issues.filter(issue => 
              new Date(issue.closed_at) < ninetyDaysAgo
            );
            
            return oldIssues.map(issue => ({
              number: issue.number,
              title: issue.title,
              closed_at: issue.closed_at
            }));
            
      - name: Archive old issues
        if: steps.old-issues.outputs.result != '[]'
        uses: actions/github-script@v6
        with:
          script: |
            const oldIssues = JSON.parse('${{ steps.old-issues.outputs.result }}');
            
            for (const issue of oldIssues) {
              // Add 'archived' label
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['archived']
                });
                
                console.log(`Archived issue #${issue.number}: ${issue.title}`);
              } catch (error) {
                console.log(`Could not archive issue #${issue.number}: ${error.message}`);
              }
            }
            
            console.log(`Archived ${oldIssues.length} old issues`);