import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import {
  WebSocketTestClient,
  generateTestJWT,
  wsMessageBuilders,
  generateWebSocketTestData
} from './setup'

describe('WebSocket Performance Tests', () => {
  let clients: WebSocketTestClient[] = []

  afterEach(async () => {
    // Clean up all clients
    for (const client of clients) {
      await client.disconnect()
    }
    clients = []
  })

  describe('Connection Performance', () => {
    it('should handle rapid connection establishment', async () => {
      const connectionCount = 20
      const connectionStartTime = Date.now()
      const connectionPromises = []

      // Create multiple connections rapidly
      for (let i = 0; i < connectionCount; i++) {
        const client = new WebSocketTestClient(generateTestJWT(`perf-user-${i}`, 'STAFF'))
        clients.push(client)
        connectionPromises.push(client.connect())
      }

      // Wait for all connections to establish
      await Promise.all(connectionPromises)
      const connectionEndTime = Date.now()

      const totalConnectionTime = connectionEndTime - connectionStartTime
      const averageConnectionTime = totalConnectionTime / connectionCount

      console.log(`Connected ${connectionCount} clients in ${totalConnectionTime}ms (avg: ${averageConnectionTime}ms per connection)`)

      // All connections should be successful
      for (const client of clients) {
        expect(client.isConnectedState).toBe(true)
      }

      // Performance assertions
      expect(totalConnectionTime).toBeLessThan(10000) // Should connect all within 10 seconds
      expect(averageConnectionTime).toBeLessThan(1000) // Average connection time under 1 second
    })

    it('should handle concurrent connections efficiently', async () => {
      const concurrentGroups = 5
      const connectionsPerGroup = 10

      for (let group = 0; group < concurrentGroups; group++) {
        const groupPromises = []

        for (let i = 0; i < connectionsPerGroup; i++) {
          const client = new WebSocketTestClient(generateTestJWT(`group-${group}-user-${i}`, 'STAFF'))
          clients.push(client)
          groupPromises.push(client.connect())
        }

        await Promise.all(groupPromises)
        console.log(`Group ${group + 1}: Connected ${connectionsPerGroup} clients`)
      }

      // All connections should be successful
      expect(clients).toHaveLength(concurrentGroups * connectionsPerGroup)
      for (const client of clients) {
        expect(client.isConnectedState).toBe(true)
      }
    })

    it('should handle connection disconnection efficiently', async () => {
      const connectionCount = 30

      // Connect all clients
      for (let i = 0; i < connectionCount; i++) {
        const client = new WebSocketTestClient(generateTestJWT(`disc-user-${i}`, 'STAFF'))
        clients.push(client)
        await client.connect()
      }

      const disconnectStartTime = Date.now()

      // Disconnect all clients
      const disconnectPromises = clients.map(client => client.disconnect())
      await Promise.all(disconnectPromises)

      const disconnectEndTime = Date.now()
      const totalDisconnectTime = disconnectEndTime - disconnectStartTime

      console.log(`Disconnected ${connectionCount} clients in ${totalDisconnectTime}ms`)

      // Performance assertions
      expect(totalDisconnectTime).toBeLessThan(5000) // Should disconnect all within 5 seconds
      expect(totalDisconnectTime / connectionCount).toBeLessThan(200) // Average under 200ms per disconnect

      // Clear clients array since they're all disconnected
      clients = []
    })
  })

  describe('Message Throughput Performance', () => {
    beforeEach(async () => {
      // Setup test clients for message throughput tests
      for (let i = 0; i < 10; i++) {
        const client = new WebSocketTestClient(generateTestJWT(`msg-user-${i}`, 'STAFF'))
        await client.connect()
        await client.waitForMessage('welcome', 2000)
        await client.sendMessage(wsMessageBuilders.subscribe(['activities']))
        await client.waitForMessage('subscription_confirmed', 2000)
        clients.push(client)
      }
    })

    it('should handle high message throughput without performance degradation', async () => {
      const messageCount = 1000
      const messagesPerSecond = 100
      const messageInterval = 1000 / messagesPerSecond

      const startTime = Date.now()
      const messagePromises = []

      for (let i = 0; i < messageCount; i++) {
        // Send messages from different clients to distribute load
        const clientIndex = i % clients.length
        const messagePromise = new Promise<void>(async (resolve) => {
          setTimeout(async () => {
            const testData = generateWebSocketTestData()
            await clients[clientIndex].sendMessage(wsMessageBuilders.logActivity({
              ...testData.activity,
              studentId: `PERF-STU-${i}`
            }))
            resolve()
          }, i * messageInterval)
        })
        messagePromises.push(messagePromise)
      }

      // Wait for all messages to be sent
      await Promise.all(messagePromises)
      const sendEndTime = Date.now()

      // Wait for all messages to be processed
      const totalExpectedUpdates = messageCount * clients.length
      const receivedMessages = []

      for (const client of clients) {
        try {
          const messages = await client.waitForMessages(messageCount / clients.length, 10000)
          receivedMessages.push(...messages)
        } catch (error) {
          console.warn('Client did not receive all expected messages:', error)
        }
      }

      const processingEndTime = Date.now()

      const sendTime = sendEndTime - startTime
      const processingTime = processingEndTime - startTime
      const actualMessagesPerSecond = (receivedMessages.length / processingTime) * 1000

      console.log(`Message throughput test results:`)
      console.log(`  Sent ${messageCount} messages in ${sendTime}ms`)
      console.log(`  Processed ${receivedMessages.length} messages in ${processingTime}ms`)
      console.log(`  Actual throughput: ${actualMessagesPerSecond.toFixed(2)} messages/second`)

      // Performance assertions
      expect(sendTime).toBeLessThan(15000) // Should send all within 15 seconds
      expect(processingTime).toBeLessThan(20000) // Should process all within 20 seconds
      expect(actualMessagesPerSecond).toBeGreaterThan(50) // Should handle at least 50 messages/second
    })

    it('should maintain performance with concurrent message sending', async () => {
      const concurrentClients = 5
      const messagesPerClient = 50

      const startTime = Date.now()
      const messagePromises = []

      // Each client sends messages concurrently
      for (let clientIndex = 0; clientIndex < concurrentClients; clientIndex++) {
        for (let messageIndex = 0; messageIndex < messagesPerClient; messageIndex++) {
          const messagePromise = clients[clientIndex].sendMessage(wsMessageBuilders.ping())
          messagePromises.push(messagePromise)
        }
      }

      await Promise.all(messagePromises)
      const sendTime = Date.now() - startTime

      // Wait for all pong responses
      const pongPromises = []
      for (const client of clients.slice(0, concurrentClients)) {
        for (let i = 0; i < messagesPerClient; i++) {
          pongPromises.push(client.waitForMessage('pong', 5000))
        }
      }

      const pongStartTime = Date.now()
      await Promise.allSettled(pongPromises)
      const pongTime = Date.now() - pongStartTime

      console.log(`Concurrent message test results:`)
      console.log(`  Sent ${concurrentClients * messagesPerClient} messages in ${sendTime}ms`)
      console.log(`  Received pong responses in ${pongTime}ms`)

      expect(sendTime).toBeLessThan(5000) // Should send all within 5 seconds
      expect(pongTime).toBeLessThan(10000) // Should receive responses within 10 seconds
    })

    it('should handle large message payloads efficiently', async () => {
      const largePayloadSize = 10000 // 10KB payload
      const largeMessage = {
        type: 'large_payload_test',
        data: {
          content: 'x'.repeat(largePayloadSize),
          metadata: {
            size: largePayloadSize,
            timestamp: new Date().toISOString(),
            clientId: 'test-client'
          }
        }
      }

      const startTime = Date.now()

      // Send large message
      await clients[0].sendMessage(largeMessage)

      const sendTime = Date.now() - startTime

      // Wait for response (likely error message due to payload size limits)
      try {
        const response = await clients[0].waitForMessage('error', 5000)
        const responseTime = Date.now() - startTime

        console.log(`Large payload test results:`)
        console.log(`  Payload size: ${largePayloadSize} bytes`)
        console.log(`  Send time: ${sendTime}ms`)
        console.log(`  Response time: ${responseTime}ms`)

        expect(response).toBeDefined()
        expect(sendTime).toBeLessThan(1000) // Should send quickly even with large payload
        expect(responseTime).toBeLessThan(5000) // Should get response within 5 seconds
      } catch (error) {
        // If no error response, verify connection is still functional
        await clients[0].sendMessage(wsMessageBuilders.ping())
        const pongResponse = await clients[0].waitForMessage('pong', 5000)
        expect(pongResponse).toBeDefined()
      }
    })
  })

  describe('Memory and Resource Usage', () => {
    it('should not leak memory with sustained connections', async () => {
      const initialMemory = process.memoryUsage()
      const testDuration = 30000 // 30 seconds
      const connectionInterval = 2000 // Create new connection every 2 seconds

      const startTime = Date.now()
      let connectionCycle = 0

      while (Date.now() - startTime < testDuration) {
        // Create new connections
        const newClients = []
        for (let i = 0; i < 3; i++) {
          const client = new WebSocketTestClient(generateTestJWT(`memory-user-${connectionCycle}-${i}`, 'STAFF'))
          await client.connect()
          await client.sendMessage(wsMessageBuilders.subscribe(['activities']))
          newClients.push(client)
          clients.push(client)
        }

        // Send some messages
        for (const client of newClients) {
          await client.sendMessage(wsMessageBuilders.ping())
          await client.waitForMessage('pong', 2000)
        }

        // Disconnect old connections (keep only last 10 connections)
        if (clients.length > 10) {
          const clientsToDisconnect = clients.splice(0, clients.length - 10)
          for (const client of clientsToDisconnect) {
            await client.disconnect()
          }
        }

        connectionCycle++
        await new Promise(resolve => setTimeout(resolve, connectionInterval))
      }

      const finalMemory = process.memoryUsage()

      console.log(`Memory usage test results:`)
      console.log(`  Test duration: ${testDuration}ms`)
      console.log(`  Connection cycles: ${connectionCycle}`)
      console.log(`  Initial heap used: ${(initialMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`)
      console.log(`  Final heap used: ${(finalMemory.heapUsed / 1024 / 1024).toFixed(2)} MB`)
      console.log(`  Memory increase: ${((finalMemory.heapUsed - initialMemory.heapUsed) / 1024 / 1024).toFixed(2)} MB`)

      // Memory should not increase significantly
      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024) // Less than 50MB increase
    })

    it('should handle CPU load efficiently during high activity', async () => {
      const testDuration = 10000 // 10 seconds
      const messageFrequency = 50 // messages per second

      const startTime = Date.now()
      let messagesSent = 0

      while (Date.now() - startTime < testDuration) {
        const messagePromises = []

        // Send messages from all clients
        for (const client of clients) {
          messagePromises.push(client.sendMessage(wsMessageBuilders.ping()))
          messagesSent++
        }

        await Promise.all(messagePromises)

        // Wait for responses
        const responsePromises = clients.map(client => client.waitForMessage('pong', 1000))
        await Promise.allSettled(responsePromises)

        // Control message frequency
        await new Promise(resolve => setTimeout(resolve, 1000 / messageFrequency))
      }

      const endTime = Date.now()
      const actualDuration = endTime - startTime
      const actualMessagesPerSecond = (messagesSent / actualDuration) * 1000

      console.log(`CPU load test results:`)
      console.log(`  Test duration: ${actualDuration}ms`)
      console.log(`  Messages sent: ${messagesSent}`)
      console.log(`  Actual message rate: ${actualMessagesPerSecond.toFixed(2)} messages/second`)

      expect(actualMessagesPerSecond).toBeGreaterThan(30) // Should handle at least 30 messages/second
      expect(actualDuration).toBeLessThan(testDuration * 1.5) // Should not take significantly longer than expected
    })
  })

  describe('Scalability Tests', () => {
    it('should scale with increasing number of connections', async () => {
      const connectionBatches = [5, 10, 15, 20]
      const performanceResults = []

      for (const batchSize of connectionBatches) {
        const batchClients = []
        const startTime = Date.now()

        // Connect batch
        for (let i = 0; i < batchSize; i++) {
          const client = new WebSocketTestClient(generateTestJWT(`scale-user-${batchSize}-${i}`, 'STAFF'))
          batchClients.push(client)
        }

        const connectionPromises = batchClients.map(client => client.connect())
        await Promise.all(connectionPromises)

        const connectionTime = Date.now() - startTime

        // Subscribe all clients
        const subscriptionStartTime = Date.now()
        const subscriptionPromises = batchClients.map(async (client) => {
          await client.sendMessage(wsMessageBuilders.subscribe(['activities']))
          return client.waitForMessage('subscription_confirmed', 2000)
        })
        await Promise.all(subscriptionPromises)
        const subscriptionTime = Date.now() - subscriptionStartTime

        // Send messages
        const messageStartTime = Date.now()
        const messagePromises = batchClients.map(client => client.sendMessage(wsMessageBuilders.ping()))
        await Promise.all(messagePromises)
        const messageSendTime = Date.now() - messageStartTime

        // Wait for responses
        const responseStartTime = Date.now()
        const responsePromises = batchClients.map(client => client.waitForMessage('pong', 3000))
        await Promise.allSettled(responsePromises)
        const responseTime = Date.now() - responseStartTime

        performanceResults.push({
          batchSize,
          connectionTime,
          subscriptionTime,
          messageSendTime,
          responseTime
        })

        // Disconnect batch clients
        for (const client of batchClients) {
          await client.disconnect()
        }

        console.log(`Batch ${batchSize}: Connection ${connectionTime}ms, Subscription ${subscriptionTime}ms, Message ${messageSendTime}ms, Response ${responseTime}ms`)
      }

      // Analyze scalability
      for (let i = 1; i < performanceResults.length; i++) {
        const current = performanceResults[i]
        const previous = performanceResults[i - 1]

        const connectionTimeRatio = current.connectionTime / previous.connectionTime
        const responseTimeRatio = current.responseTime / previous.responseTime

        console.log(`Scalability from ${previous.batchSize} to ${current.batchSize} connections:`)
        console.log(`  Connection time ratio: ${connectionTimeRatio.toFixed(2)}`)
        console.log(`  Response time ratio: ${responseTimeRatio.toFixed(2)}`)

        // Performance should scale linearly, not exponentially
        expect(connectionTimeRatio).toBeLessThan(3) // Connection time shouldn't triple when connections double
        expect(responseTimeRatio).toBeLessThan(2.5) // Response time shouldn't more than double
      }
    })
  })
})