import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import {
  WebSocketTestClient,
  generateTestJWT,
  wsMessageBuilders,
  generateWebSocketTestData,
  prisma
} from './setup'

describe('WebSocket Real-Time Functionality Tests', () => {
  let adminClient: WebSocketTestClient
  let librarianClient: WebSocketTestClient
  let staffClient: WebSocketTestClient

  beforeEach(async () => {
    // Create authenticated WebSocket clients
    adminClient = new WebSocketTestClient(generateTestJWT('ws-admin', 'ADMIN'))
    librarianClient = new WebSocketTestClient(generateTestJWT('ws-librarian', 'LIBRARIAN'))
    staffClient = new WebSocketTestClient(generateTestJWT('ws-staff', 'STAFF'))

    await adminClient.connect()
    await librarianClient.connect()
    await staffClient.connect()

    // Wait for welcome messages
    await adminClient.waitForMessage('welcome', 2000)
    await librarianClient.waitForMessage('welcome', 2000)
    await staffClient.waitForMessage('welcome', 2000)
  })

  afterEach(async () => {
    await adminClient.disconnect()
    await librarianClient.disconnect()
    await staffClient.disconnect()
  })

  describe('Activity Real-Time Updates', () => {
    it('should broadcast activity updates to subscribed clients', async () => {
      // Subscribe all clients to activity updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['activities']))
      await librarianClient.sendMessage(wsMessageBuilders.subscribe(['activities']))
      await staffClient.sendMessage(wsMessageBuilders.subscribe(['activities']))

      // Wait for subscription confirmations
      await adminClient.waitForMessage('subscription_confirmed', 2000)
      await librarianClient.waitForMessage('subscription_confirmed', 2000)
      await staffClient.waitForMessage('subscription_confirmed', 2000)

      // Create test activity via WebSocket
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      // All clients should receive the activity update
      const adminActivityUpdate = await adminClient.waitForMessage('activity_update', 5000)
      const librarianActivityUpdate = await librarianClient.waitForMessage('activity_update', 5000)
      const staffActivityUpdate = await staffClient.waitForMessage('activity_update', 5000)

      expect(adminActivityUpdate).toBeDefined()
      expect(adminActivityUpdate.data.activityType).toBe(testData.activity.activityType)
      expect(adminActivityUpdate.data.studentId).toContain('WS-STU')

      expect(librarianActivityUpdate).toBeDefined()
      expect(librarianActivityUpdate.data.activityType).toBe(testData.activity.activityType)

      expect(staffActivityUpdate).toBeDefined()
      expect(staffActivityUpdate.data.activityType).toBe(testData.activity.activityType)
    })

    it('should not send activity updates to unsubscribed clients', async () => {
      // Subscribe only admin to activity updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['activities']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Librarian and staff are not subscribed

      // Create test activity
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      // Only admin should receive the update
      const adminActivityUpdate = await adminClient.waitForMessage('activity_update', 5000)
      expect(adminActivityUpdate).toBeDefined()

      // Librarian and staff should not receive activity updates
      try {
        await librarianClient.waitForMessage('activity_update', 2000)
        expect.fail('Librarian should not receive activity update when not subscribed')
      } catch (error) {
        // Expected - timeout waiting for message
      }

      try {
        await staffClient.waitForMessage('activity_update', 2000)
        expect.fail('Staff should not receive activity update when not subscribed')
      } catch (error) {
        // Expected - timeout waiting for message
      }
    })

    it('should handle activity status updates in real-time', async () => {
      // Subscribe to activity updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['activities']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Create activity
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      // Get the created activity
      const activityUpdate = await adminClient.waitForMessage('activity_update', 5000)
      const activityId = activityUpdate.data.id

      // Update activity status
      await adminClient.sendMessage({
        type: 'update_activity_status',
        data: {
          activityId,
          status: 'COMPLETED',
          endTime: new Date().toISOString()
        }
      })

      // Should receive status update
      const statusUpdate = await adminClient.waitForMessage('activity_status_update', 5000)
      expect(statusUpdate).toBeDefined()
      expect(statusUpdate.data.activityId).toBe(activityId)
      expect(statusUpdate.data.status).toBe('COMPLETED')
      expect(statusUpdate.data.endTime).toBeDefined()
    })
  })

  describe('Equipment Real-Time Updates', () => {
    it('should broadcast equipment status changes', async () => {
      // Subscribe all clients to equipment updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['equipment']))
      await librarianClient.sendMessage(wsMessageBuilders.subscribe(['equipment']))
      await staffClient.sendMessage(wsMessageBuilders.subscribe(['equipment']))

      // Wait for subscription confirmations
      await adminClient.waitForMessage('subscription_confirmed', 2000)
      await librarianClient.waitForMessage('subscription_confirmed', 2000)
      await staffClient.waitForMessage('subscription_confirmed', 2000)

      // Get available equipment
      await adminClient.sendMessage(wsMessageBuilders.getEquipmentStatus())
      const equipmentStatus = await adminClient.waitForMessage('equipment_status', 5000)

      expect(equipmentStatus).toBeDefined()
      expect(equipmentStatus.data.equipment).toBeInstanceOf(Array)

      const availableEquipment = equipmentStatus.data.equipment.find((eq: any) => eq.status === 'AVAILABLE')
      expect(availableEquipment).toBeDefined()

      // Request equipment (change status to IN_USE)
      await adminClient.sendMessage(wsMessageBuilders.requestEquipment(
        availableEquipment.id,
        'WS-STU-001'
      ))

      // All clients should receive equipment status update
      const adminEquipmentUpdate = await adminClient.waitForMessage('equipment_status_update', 5000)
      const librarianEquipmentUpdate = await librarianClient.waitForMessage('equipment_status_update', 5000)
      const staffEquipmentUpdate = await staffClient.waitForMessage('equipment_status_update', 5000)

      expect(adminEquipmentUpdate).toBeDefined()
      expect(adminEquipmentUpdate.data.equipmentId).toBe(availableEquipment.id)
      expect(adminEquipmentUpdate.data.status).toBe('IN_USE')

      expect(librarianEquipmentUpdate).toBeDefined()
      expect(librarianEquipmentUpdate.data.status).toBe('IN_USE')

      expect(staffEquipmentUpdate).toBeDefined()
      expect(staffEquipmentUpdate.data.status).toBe('IN_USE')
    })

    it('should handle equipment session real-time updates', async () => {
      // Subscribe to equipment updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['equipment']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Get equipment and start a session
      await adminClient.sendMessage(wsMessageBuilders.getEquipmentStatus())
      const equipmentStatus = await adminClient.waitForMessage('equipment_status', 5000)
      const availableEquipment = equipmentStatus.data.equipment.find((eq: any) => eq.status === 'AVAILABLE')

      await adminClient.sendMessage(wsMessageBuilders.requestEquipment(
        availableEquipment.id,
        'WS-STU-002'
      ))

      const sessionUpdate = await adminClient.waitForMessage('equipment_session_update', 5000)
      expect(sessionUpdate).toBeDefined()
      expect(sessionUpdate.data.equipmentId).toBe(availableEquipment.id)
      expect(sessionUpdate.data.studentId).toBe('WS-STU-002')
      expect(sessionUpdate.data.status).toBe('ACTIVE')

      const sessionId = sessionUpdate.data.sessionId

      // End the session
      await adminClient.sendMessage(wsMessageBuilders.releaseEquipment(sessionId))

      const sessionEndUpdate = await adminClient.waitForMessage('equipment_session_end', 5000)
      expect(sessionEndUpdate).toBeDefined()
      expect(sessionEndUpdate.data.sessionId).toBe(sessionId)
      expect(sessionEndUpdate.data.status).toBe('COMPLETED')
    })
  })

  describe('Real-Time Analytics', () => {
    it('should provide real-time activity statistics', async () => {
      // Subscribe to analytics updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['analytics']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Request activity statistics
      await adminClient.sendMessage(wsMessageBuilders.getActivityStats('day'))

      const statsUpdate = await adminClient.waitForMessage('activity_stats', 5000)
      expect(statsUpdate).toBeDefined()
      expect(statsUpdate.data.timeframe).toBe('day')
      expect(statsUpdate.data.statistics).toBeDefined()
      expect(statsUpdate.data.statistics.totalActivities).toBeDefined()
      expect(statsUpdate.data.statistics.activeSessions).toBeDefined()
    })

    it('should update analytics in real-time as activities occur', async () => {
      // Subscribe to analytics updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['analytics']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Get initial stats
      await adminClient.sendMessage(wsMessageBuilders.getActivityStats('day'))
      const initialStats = await adminClient.waitForMessage('activity_stats', 5000)
      const initialCount = initialStats.data.statistics.totalActivities

      // Create multiple activities
      const testData = generateWebSocketTestData()
      for (let i = 0; i < 3; i++) {
        await adminClient.sendMessage(wsMessageBuilders.logActivity({
          ...testData.activity,
          studentId: `WS-STU-${100 + i}`,
          equipmentId: `WS-EQ-${100 + i}`
        }))

        // Wait for activity update
        await adminClient.waitForMessage('activity_update', 3000)
      }

      // Get updated stats
      await adminClient.sendMessage(wsMessageBuilders.getActivityStats('day'))
      const updatedStats = await adminClient.waitForMessage('activity_stats', 5000)

      expect(updatedStats.data.statistics.totalActivities).toBe(initialCount + 3)
    })

    it('should broadcast analytics updates to multiple clients', async () => {
      // Subscribe multiple clients to analytics
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['analytics']))
      await librarianClient.sendMessage(wsMessageBuilders.subscribe(['analytics']))

      await adminClient.waitForMessage('subscription_confirmed', 2000)
      await librarianClient.waitForMessage('subscription_confirmed', 2000)

      // Create activity to trigger analytics update
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      // Both clients should receive analytics updates
      const adminAnalyticsUpdate = await adminClient.waitForMessage('analytics_update', 5000)
      const librarianAnalyticsUpdate = await librarianClient.waitForMessage('analytics_update', 5000)

      expect(adminAnalyticsUpdate).toBeDefined()
      expect(adminAnalyticsUpdate.data.type).toBe('activity_count_change')

      expect(librarianAnalyticsUpdate).toBeDefined()
      expect(librarianAnalyticsUpdate.data.type).toBe('activity_count_change')
    })
  })

  describe('Real-Time Notifications', () => {
    it('should send system notifications to subscribed clients', async () => {
      // Subscribe to notifications
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['notifications']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Trigger a system notification (e.g., equipment maintenance)
      await adminClient.sendMessage({
        type: 'trigger_system_notification',
        data: {
          type: 'equipment_maintenance',
          message: 'Test equipment scheduled for maintenance',
          equipmentId: 'test-equipment-id'
        }
      })

      const notification = await adminClient.waitForMessage('system_notification', 5000)
      expect(notification).toBeDefined()
      expect(notification.data.type).toBe('equipment_maintenance')
      expect(notification.data.message).toContain('maintenance')
    })

    it('should send targeted notifications to specific users', async () => {
      // Subscribe both clients to notifications
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['notifications']))
      await librarianClient.sendMessage(wsMessageBuilders.subscribe(['notifications']))

      await adminClient.waitForMessage('subscription_confirmed', 2000)
      await librarianClient.waitForMessage('subscription_confirmed', 2000)

      // Send targeted notification to librarian only
      await adminClient.sendMessage({
        type: 'send_targeted_notification',
        data: {
          targetUser: 'ws-librarian',
          message: 'This notification is for librarian only',
          type: 'personal'
        }
      })

      // Librarian should receive the notification
      const librarianNotification = await librarianClient.waitForMessage('targeted_notification', 5000)
      expect(librarianNotification).toBeDefined()
      expect(librarianNotification.data.message).toContain('librarian only')

      // Admin should not receive this targeted notification
      try {
        await adminClient.waitForMessage('targeted_notification', 2000)
        expect.fail('Admin should not receive librarian-specific notification')
      } catch (error) {
        // Expected - timeout
      }
    })
  })

  describe('Real-Time Dashboard Updates', () => {
    it('should provide comprehensive dashboard updates', async () => {
      // Subscribe to dashboard updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['dashboard']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Request dashboard data
      await adminClient.sendMessage({
        type: 'get_dashboard_data',
        data: { timeframe: 'day' }
      })

      const dashboardUpdate = await adminClient.waitForMessage('dashboard_update', 5000)
      expect(dashboardUpdate).toBeDefined()
      expect(dashboardUpdate.data.summary).toBeDefined()
      expect(dashboardUpdate.data.recentActivities).toBeDefined()
      expect(dashboardUpdate.data.equipmentStatus).toBeDefined()
      expect(dashboardUpdate.data.alerts).toBeDefined()
    })

    it('should update dashboard data in real-time', async () => {
      // Subscribe to dashboard updates
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['dashboard']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Get initial dashboard data
      await adminClient.sendMessage({
        type: 'get_dashboard_data',
        data: { timeframe: 'day' }
      })
      const initialDashboard = await adminClient.waitForMessage('dashboard_update', 5000)
      const initialActivityCount = initialDashboard.data.summary.totalActivities

      // Create new activity
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      // Should receive dashboard update with new activity
      const updatedDashboard = await adminClient.waitForMessage('dashboard_update', 5000)
      expect(updatedDashboard.data.summary.totalActivities).toBe(initialActivityCount + 1)
      expect(updatedDashboard.data.recentActivities).toBeInstanceOf(Array)
      expect(updatedDashboard.data.recentActivities.length).toBeGreaterThan(0)
    })
  })

  describe('Subscription Management', () => {
    it('should handle multiple subscriptions correctly', async () => {
      // Subscribe to multiple topics
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['activities', 'equipment', 'analytics']))

      // Should receive confirmation for each subscription
      const confirmations = await adminClient.waitForMessages(3, 5000)
      expect(confirmations).toHaveLength(3)
      expect(confirmations.every(c => c.type === 'subscription_confirmed')).toBe(true)

      // Create activity - should receive activity update
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))
      const activityUpdate = await adminClient.waitForMessage('activity_update', 5000)
      expect(activityUpdate).toBeDefined()

      // Get equipment status - should receive equipment data
      await adminClient.sendMessage(wsMessageBuilders.getEquipmentStatus())
      const equipmentStatus = await adminClient.waitForMessage('equipment_status', 5000)
      expect(equipmentStatus).toBeDefined()
    })

    it('should handle subscription removal correctly', async () => {
      // Subscribe to activities
      await adminClient.sendMessage(wsMessageBuilders.subscribe(['activities']))
      await adminClient.waitForMessage('subscription_confirmed', 2000)

      // Unsubscribe from activities
      await adminClient.sendMessage(wsMessageBuilders.unsubscribe(['activities']))
      const unsubscriptionConfirm = await adminClient.waitForMessage('unsubscription_confirmed', 5000)
      expect(unsubscriptionConfirm).toBeDefined()
      expect(unsubscriptionConfirm.data.subscriptions).toContain('activities')

      // Create activity - should not receive update
      const testData = generateWebSocketTestData()
      await adminClient.sendMessage(wsMessageBuilders.logActivity(testData.activity))

      try {
        await adminClient.waitForMessage('activity_update', 2000)
        expect.fail('Should not receive activity update after unsubscription')
      } catch (error) {
        // Expected - timeout
      }
    })
  })
})