import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import {
  analyticsService,
  prisma,
  seedAnalyticsData,
  validateTimeSeriesData,
  validatePredictiveInsight,
  validateHeatMapData,
  validateResourceForecast
} from './setup'

describe('Analytics Accuracy Tests', () => {
  beforeEach(async () => {
    // Seed test data for each accuracy test
    await seedAnalyticsData(200, 100)
  })

  afterEach(async () => {
    // Clean up activities and checkouts
    await prisma.activity.deleteMany()
    await prisma.bookCheckout.deleteMany()
  })

  describe('Predictive Insights Accuracy', () => {
    it('should generate accurate demand forecasts', async () => {
      const insights = await analyticsService.generatePredictiveInsights('week')

      expect(insights).toBeInstanceOf(Array)
      expect(insights.length).toBeGreaterThan(0)

      const demandForecast = insights.find(insight => insight.type === 'demand_forecast')
      expect(demandForecast).toBeDefined()

      validatePredictiveInsight(demandForecast)
      expect(demandForecast.data).toHaveProperty('current')
      expect(demandForecast.data).toHaveProperty('predicted')
      expect(demandForecast.data).toHaveProperty('trend')

      // Verify forecast is based on historical data
      expect(typeof demandForecast.data.current).toBe('number')
      expect(typeof demandForecast.data.predicted).toBe('number')
      expect(typeof demandForecast.data.trend).toBe('number')
    })

    it('should provide accurate peak usage predictions', async () => {
      const insights = await analyticsService.generatePredictiveInsights('week')

      const peakPrediction = insights.find(insight => insight.type === 'peak_prediction')
      expect(peakPrediction).toBeDefined()

      validatePredictiveInsight(peakPrediction)
      expect(peakPrediction.data).toHaveProperty('peakHours')
      expect(peakPrediction.data).toHaveProperty('peakDays')
      expect(peakPrediction.data).toHaveProperty('hourlyDistribution')
      expect(peakPrediction.data).toHaveProperty('weeklyDistribution')

      // Verify peak hours are within valid range
      expect(peakPrediction.data.peakHours).toBeInstanceOf(Array)
      peakPrediction.data.peakHours.forEach((hour: number) => {
        expect(hour).toBeGreaterThanOrEqual(0)
        expect(hour).toBeLessThanOrEqual(23)
      })

      // Verify peak days are within valid range
      expect(peakPrediction.data.peakDays).toBeInstanceOf(Array)
      peakPrediction.data.peakDays.forEach((day: number) => {
        expect(day).toBeGreaterThanOrEqual(0)
        expect(day).toBeLessThanOrEqual(6)
      })
    })

    it('should identify resource optimization opportunities accurately', async () => {
      const insights = await analyticsService.generatePredictiveInsights('week')

      const resourceOptimization = insights.find(insight => insight.type === 'resource_optimization')
      expect(resourceOptimization).toBeDefined()

      validatePredictiveInsight(resourceOptimization)
      expect(resourceOptimization.data).toHaveProperty('utilizationRates')
      expect(resourceOptimization.data).toHaveProperty('underutilized')
      expect(resourceOptimization.data).toHaveProperty('overutilized')

      // Verify utilization rates are valid percentages
      Object.values(resourceOptimization.data.utilizationRates).forEach((rate: any) => {
        expect(typeof rate).toBe('number')
        expect(rate).toBeGreaterThanOrEqual(0)
        expect(rate).toBeLessThanOrEqual(100)
      })

      // Verify underutilized resources have low utilization
      if (resourceOptimization.data.underutilized.length > 0) {
        resourceOptimization.data.underutilized.forEach((resource: any) => {
          expect(resource.rate).toBeLessThan(30)
        })
      }

      // Verify overutilized resources have high utilization
      if (resourceOptimization.data.overutilized.length > 0) {
        resourceOptimization.data.overutilized.forEach((resource: any) => {
          expect(resource.rate).toBeGreaterThan(80)
        })
      }
    })

    it('should detect usage anomalies accurately', async () => {
      const insights = await analyticsService.generatePredictiveInsights('week')

      const anomalies = insights.filter(insight => insight.type === 'anomaly_detection')

      if (anomalies.length > 0) {
        anomalies.forEach(anomaly => {
          validatePredictiveInsight(anomaly)
          expect(anomaly.data).toHaveProperty('anomalies')
          expect(anomaly.data).toHaveProperty('mean')
          expect(anomaly.data).toHaveProperty('stdDev')
          expect(anomaly.data).toHaveProperty('threshold')

          // Verify anomalies are statistically significant
          expect(typeof anomaly.data.mean).toBe('number')
          expect(typeof anomaly.data.stdDev).toBe('number')
          expect(anomaly.data.threshold).toBe(2) // 2 standard deviations

          expect(anomaly.data.anomalies).toBeInstanceOf(Array)
          expect(anomaly.data.anomalies.length).toBeGreaterThan(0)
        })
      }
    })

    it('should maintain insight confidence levels realistically', async () => {
      const insights = await analyticsService.generatePredictiveInsights('week')

      insights.forEach(insight => {
        validatePredictiveInsight(insight)

        // Confidence should be between 0 and 1
        expect(insight.confidence).toBeGreaterThanOrEqual(0)
        expect(insight.confidence).toBeLessThanOrEqual(1)

        // More recent data should generally have higher confidence
        if (insight.type === 'demand_forecast') {
          expect(insight.confidence).toBeGreaterThanOrEqual(0.5) // Minimum reasonable confidence
        }
      })

      // Insights should be sorted by confidence (highest first)
      for (let i = 1; i < insights.length; i++) {
        expect(insights[i-1].confidence).toBeGreaterThanOrEqual(insights[i].confidence)
      }
    })
  })

  describe('Time Series Forecast Accuracy', () => {
    it('should generate accurate student visit forecasts', async () => {
      const forecast = await analyticsService.generateTimeSeriesForecast('student_visits', 'week', 7)

      validateTimeSeriesData(forecast, 14) // 7 historical + 7 predicted

      // Historical data should have actual values
      const historicalData = forecast.slice(0, 7)
      historicalData.forEach(point => {
        expect(point.value).toBeGreaterThan(0)
        expect(point.predicted).toBeUndefined()
      })

      // Predicted data should have predictions and bounds
      const predictedData = forecast.slice(7)
      predictedData.forEach(point => {
        expect(point.value).toBe(0) // No actual value yet
        expect(point.predicted).toBeGreaterThan(0)
        expect(point.upperBound).toBeDefined()
        expect(point.lowerBound).toBeDefined()
        expect(point.upperBound).toBeGreaterThanOrEqual(point.predicted)
        expect(point.lowerBound).toBeLessThanOrEqual(point.predicted)
      })
    })

    it('should generate accurate equipment usage forecasts', async () => {
      const forecast = await analyticsService.generateTimeSeriesForecast('equipment_usage', 'week', 7)

      validateTimeSeriesData(forecast, 14)

      // Verify equipment-specific patterns
      const totalUsage = forecast.slice(0, 7).reduce((sum, point) => sum + point.value, 0)
      expect(totalUsage).toBeGreaterThan(0)

      // Predictions should be reasonable
      const predictedData = forecast.slice(7)
      predictedData.forEach(point => {
        expect(point.predicted).toBeGreaterThan(0)
        expect(point.predicted).toBeLessThan(100) // Reasonable maximum per day
      })
    })

    it('should generate accurate book circulation forecasts', async () => {
      const forecast = await analyticsService.generateTimeSeriesForecast('book_circulation', 'week', 7)

      validateTimeSeriesData(forecast, 14)

      // Book circulation should be relatively stable
      const historicalValues = forecast.slice(0, 7).map(point => point.value)
      const variance = Math.max(...historicalValues) - Math.min(...historicalValues)
      expect(variance).toBeLessThan((historicalValues.reduce((sum, val) => sum + val, 0) / historicalValues.length) * 2)
    })

    it('should maintain prediction confidence over time', async () => {
      const forecast = await analyticsService.generateTimeSeriesForecast('student_visits', 'week', 14)

      const predictedData = forecast.slice(7) // Only predicted points

      // Confidence should decrease as predictions get further into the future
      let lastConfidence = 1.0
      for (let i = 0; i < predictedData.length - 1; i++) {
        const currentPoint = predictedData[i]
        const nextPoint = predictedData[i + 1]

        const currentMargin = currentPoint.upperBound - currentPoint.predicted
        const nextMargin = nextPoint.upperBound - nextPoint.predicted

        // Margin of error should increase (confidence decreases) over time
        expect(nextMargin).toBeGreaterThanOrEqual(currentMargin * 0.9) // Allow some fluctuation
      }
    })
  })

  describe('Heat Map Data Accuracy', () => {
    it('should generate accurate usage heat maps', async () => {
      const heatMapData = await analyticsService.generateUsageHeatMap('week')

      validateHeatMapData(heatMapData)
      expect(heatMapData.length).toBeGreaterThan(0)

      // Verify data covers all days and hours
      const days = new Set(heatMapData.map(point => point.dayOfWeek))
      const hours = new Set(heatMapData.map(point => point.hour))

      expect(days.size).toBeGreaterThan(0)
      expect(hours.size).toBeGreaterThan(0)

      // Should have data for typical library hours
      const typicalHours = Array.from({length: 11}, (_, i) => i + 8) // 8 AM - 6 PM
      typicalHours.forEach(hour => {
        expect(hours.has(hour)).toBe(true)
      })
    })

    it('should show realistic intensity patterns', async () => {
      const heatMapData = await analyticsService.generateUsageHeatMap('week')

      // Intensity should vary realistically
      const intensities = heatMapData.map(point => point.intensity)
      const maxIntensity = Math.max(...intensities)
      const minIntensity = Math.min(...intensities)

      expect(maxIntensity).toBeGreaterThan(minIntensity)
      expect(maxIntensity).toBeGreaterThan(0)

      // Peak hours should have higher intensity
      const peakHours = [9, 10, 11, 14, 15, 16] // Typical peak hours
      const peakHourData = heatMapData.filter(point => peakHours.includes(point.hour))
      const nonPeakHourData = heatMapData.filter(point => !peakHours.includes(point.hour))

      if (peakHourData.length > 0 && nonPeakHourData.length > 0) {
        const avgPeakIntensity = peakHourData.reduce((sum, point) => sum + point.intensity, 0) / peakHourData.length
        const avgNonPeakIntensity = nonPeakHourData.reduce((sum, point) => sum + point.intensity, 0) / nonPeakHourData.length

        expect(avgPeakIntensity).toBeGreaterThan(avgNonPeakIntensity * 0.8) // Peak should be higher
      }
    })

    it('should differentiate activity types in heat map', async () => {
      const heatMapData = await analyticsService.generateUsageHeatMap('week')

      // Should have different patterns for different activity types
      const activityTypes = new Set(heatMapData.map(point => point.activityType).filter(Boolean))

      if (activityTypes.size > 1) {
        const activitiesByType = Array.from(activityTypes).map(type => ({
          type,
          data: heatMapData.filter(point => point.activityType === type)
        }))

        // Different activity types should have different patterns
        activitiesByType.forEach((activity, index) => {
          if (index > 0) {
            const prevActivity = activitiesByType[index - 1]
            const currentPeakHour = activity.data.reduce((max, point) =>
              point.intensity > max.intensity ? point : max, activity.data[0]).hour
            const prevPeakHour = prevActivity.data.reduce((max, point) =>
              point.intensity > max.intensity ? point : max, prevActivity.data[0]).hour

            // Peak hours might differ between activity types
            expect(typeof currentPeakHour).toBe('number')
            expect(typeof prevPeakHour).toBe('number')
          }
        })
      }
    })
  })

  describe('Seasonal Pattern Accuracy', () => {
    it('should detect realistic daily patterns', async () => {
      const patterns = await analyticsService.analyzeSeasonalPatterns()

      expect(patterns).toBeInstanceOf(Array)
      expect(patterns.length).toBeGreaterThan(0)

      const dailyPattern = patterns.find(p => p.period === 'daily')
      expect(dailyPattern).toBeDefined()
      expect(dailyPattern.pattern).toHaveLength(24) // 24 hours
      expect(dailyPattern.peakTimes).toBeInstanceOf(Array)
      expect(dailyPattern.trend).toMatch(/^(increasing|decreasing|stable)$/)
      expect(typeof dailyPattern.seasonality).toBe('number')
      expect(dailyPattern.seasonality).toBeGreaterThanOrEqual(0)
      expect(dailyPattern.seasonality).toBeLessThanOrEqual(1)

      // Peak times should be during library hours
      dailyPattern.peakTimes.forEach((peakHour: number) => {
        expect(peakHour).toBeGreaterThanOrEqual(8)
        expect(peakHour).toBeLessThanOrEqual(18)
      })
    })

    it('should detect realistic weekly patterns', async () => {
      const patterns = await analyticsService.analyzeSeasonalPatterns()

      const weeklyPattern = patterns.find(p => p.period === 'weekly')
      expect(weeklyPattern).toBeDefined()
      expect(weeklyPattern.pattern).toHaveLength(7) // 7 days
      expect(weeklyPattern.peakTimes).toBeInstanceOf(Array)

      // Weekday patterns should generally be stronger than weekends
      const weekdayAvg = weeklyPattern.pattern.slice(0, 5).reduce((sum, val) => sum + val, 0) / 5
      const weekendAvg = weeklyPattern.pattern.slice(5).reduce((sum, val) => sum + val, 0) / 2

      // This might vary based on the specific library, but generally weekdays should be busier
      expect(typeof weekdayAvg).toBe('number')
      expect(typeof weekendAvg).toBe('number')
    })

    it('should calculate seasonality strength correctly', async () => {
      const patterns = await analyticsService.analyzeSeasonalPatterns()

      patterns.forEach(pattern => {
        expect(typeof pattern.seasonality).toBe('number')
        expect(pattern.seasonality).toBeGreaterThanOrEqual(0)
        expect(pattern.seasonality).toBeLessThanOrEqual(1)

        // Higher seasonality should indicate more distinct patterns
        const maxValue = Math.max(...pattern.pattern)
        const minValue = Math.min(...pattern.pattern)
        const range = maxValue - minValue

        if (pattern.seasonality > 0.5) {
          expect(range).toBeGreaterThan(maxValue * 0.5) // Significant variation
        }
      })
    })
  })

  describe('Resource Forecast Accuracy', () => {
    it('should generate accurate resource utilization forecasts', async () => {
      const forecasts = await analyticsService.generateResourceForecasts('week')

      expect(forecasts).toBeInstanceOf(Array)
      expect(forecasts.length).toBeGreaterThan(0)

      forecasts.forEach(forecast => {
        validateResourceForecast(forecast)

        // Current utilization should be based on actual data
        expect(typeof forecast.currentUtilization).toBe('number')
        expect(forecast.currentUtilization).toBeGreaterThanOrEqual(0)
        expect(forecast.currentUtilization).toBeLessThanOrEqual(100)

        // Predicted utilization should be an array
        expect(forecast.predictedUtilization).toBeInstanceOf(Array)
        expect(forecast.predictedUtilization.length).toBeGreaterThan(0)

        forecast.predictedUtilization.forEach((utilization: number) => {
          expect(typeof utilization).toBe('number')
          expect(utilization).toBeGreaterThanOrEqual(0)
          expect(utilization).toBeLessThanOrEqual(100)
        })

        // Recommended capacity should be reasonable
        expect(typeof forecast.recommendedCapacity).toBe('number')
        expect(forecast.recommendedCapacity).toBeGreaterThanOrEqual(0)
        expect(forecast.recommendedCapacity).toBeLessThanOrEqual(100)
      })
    })

    it('should assess risk levels appropriately', async () => {
      const forecasts = await analyticsService.generateResourceForecasts('week')

      forecasts.forEach(forecast => {
        validateResourceForecast(forecast)

        const maxPredictedUtilization = Math.max(...forecast.predictedUtilization)
        const utilizationIncrease = maxPredictedUtilization - forecast.currentUtilization

        // Risk assessment should be logical
        if (forecast.riskLevel === 'high') {
          expect(maxPredictedUtilization).toBeGreaterThan(90)
          expect(utilizationIncrease).toBeGreaterThan(20)
        } else if (forecast.riskLevel === 'medium') {
          expect(
            (maxPredictedUtilization > 75) ||
            (utilizationIncrease > 20)
          ).toBe(true)
        } else { // low risk
          expect(maxPredictedUtilization).toBeLessThanOrEqual(90)
          expect(utilizationIncrease).toBeLessThanOrEqual(20)
        }
      })
    })

    it('should provide consistent forecasts across resource types', async () => {
      const forecasts = await analyticsService.generateResourceForecasts('week')

      const resourceTypes = forecasts.map(f => f.resourceType)
      expect(resourceTypes).toContain('computer')
      expect(resourceTypes).toContain('gaming')
      expect(resourceTypes).toContain('study_area')
      expect(resourceTypes).toContain('books')

      // Different resource types should have different utilization patterns
      const computerForecast = forecasts.find(f => f.resourceType === 'computer')
      const gamingForecast = forecasts.find(f => f.resourceType === 'gaming')

      if (computerForecast && gamingForecast) {
        // Both should have valid data but potentially different patterns
        expect(computerForecast.currentUtilization).toBeGreaterThanOrEqual(0)
        expect(gamingForecast.currentUtilization).toBeGreaterThanOrEqual(0)
      }
    })
  })

  describe('Analytics Report Accuracy', () => {
    it('should generate comprehensive insights reports', async () => {
      const report = await analyticsService.generateInsightsReport('week')

      expect(report).toHaveProperty('summary')
      expect(report).toHaveProperty('insights')
      expect(report).toHaveProperty('recommendations')
      expect(report).toHaveProperty('keyMetrics')

      // Summary should be descriptive
      expect(typeof report.summary).toBe('string')
      expect(report.summary.length).toBeGreaterThan(0)

      // Insights should be validated
      expect(report.insights).toBeInstanceOf(Array)
      report.insights.forEach(insight => {
        validatePredictiveInsight(insight)
      })

      // Recommendations should be actionable
      expect(report.recommendations).toBeInstanceOf(Array)
      report.recommendations.forEach((recommendation: string) => {
        expect(typeof recommendation).toBe('string')
        expect(recommendation.length).toBeGreaterThan(0)
      })

      // Key metrics should be numeric
      expect(typeof report.keyMetrics).toBe('object')
      expect(report.keyMetrics.totalInsights).toBe(report.insights.length)
      expect(report.keyMetrics.highImpactCount).toBeGreaterThanOrEqual(0)
      expect(report.keyMetrics.highImpactCount).toBeLessThanOrEqual(report.insights.length)
    })

    it('should provide accurate key metrics', async () => {
      const report = await analyticsService.generateInsightsReport('week')

      expect(typeof report.keyMetrics.totalInsights).toBe('number')
      expect(typeof report.keyMetrics.highImpactCount).toBe('number')
      expect(typeof report.keyMetrics.averageConfidence).toBe('number')
      expect(typeof report.keyMetrics.seasonalStrength).toBe('number')
      expect(typeof report.keyMetrics.resourceRisk).toBe('number')

      // Average confidence should be calculated correctly
      const expectedAvgConfidence = report.insights.reduce((sum: number, insight: any) => sum + insight.confidence, 0) / report.insights.length
      expect(Math.abs(report.keyMetrics.averageConfidence - expectedAvgConfidence)).toBeLessThan(0.01)

      // High impact count should match insights
      const expectedHighImpactCount = report.insights.filter((insight: any) => insight.impact === 'high').length
      expect(report.keyMetrics.highImpactCount).toBe(expectedHighImpactCount)
    })

    it('should aggregate recommendations intelligently', async () => {
      const report = await analyticsService.generateInsightsReport('week')

      // Recommendations should be unique
      const uniqueRecommendations = [...new Set(report.recommendations)]
      expect(uniqueRecommendations.length).toBe(report.recommendations.length)

      // Recommendations should come from insights
      const insightRecommendations = report.insights.flatMap((insight: any) => insight.recommendations)
      report.recommendations.forEach((recommendation: string) => {
        expect(insightRecommendations).toContain(recommendation)
      })

      // Should have a reasonable number of recommendations
      expect(report.recommendations.length).toBeGreaterThan(0)
      expect(report.recommendations.length).toBeLessThanOrEqual(20) // Reasonable upper limit
    })
  })
})