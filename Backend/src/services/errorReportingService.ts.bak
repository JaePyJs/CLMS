import { randomUUID } from 'crypto';
import {
  PrismaClient,
  Prisma,
  type audit_logs as AuditLogModel,
} from '@prisma/client';
import { BaseError } from '@/utils/errors';
import { logger } from '@/utils/logger';
import {
  categorizeError,
  ErrorCategory,
  ErrorSeverity,
  getErrorMetrics,
  getErrorTrends,
} from '@/middleware/errorMiddleware';

export interface ErrorContextData {
  requestId: string;
  userId?: string;
  ip: string;
  userAgent: string;
  method: string;
  url: string;
  body?: unknown;
  query?: unknown;
  params?: unknown;
  timestamp: Date;
  duration: number;
}
export interface ErrorReport {
  id: string;
  timestamp: Date;
  message: string;
  category: ErrorCategory;
  severity: ErrorSeverity;
  statusCode?: number;
  code?: string;
  stack?: string;
  context: ErrorContextData;
  resolved: boolean;
  resolvedAt?: Date;
  resolvedBy?: string;
  resolutionNotes?: string;
  assignee?: string;
  tags: string[];
  similarErrors: number;
  impact: {
    usersAffected: number;
    requestsAffected: number;
    downtimeMinutes?: number;
  };
}

export interface ErrorReportFilter {
  category?: ErrorCategory | string;
  severity?: ErrorSeverity | string;
  resolved?: boolean;
  assignee?: string;
  startDate?: Date;
  endDate?: Date;
  search?: string;
  tags?: string[];
}

export interface ErrorTrend {
  date: string;
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  categories: Record<ErrorCategory, number>;
}

export interface ErrorDashboard {
  overview: {
    totalErrors: number;
    unresolvedErrors: number;
    criticalErrors: number;
    errorsLast24h: number;
    errorRate: number;
    uptime: number;
  };
  trends: ErrorTrend[];
  topErrors: Array<{
    id: string;
    message: string;
    count: number;
    severity: ErrorSeverity;
    lastOccurred: Date;
  }>;
  categoryBreakdown: Array<{
    category: ErrorCategory;
    count: number;
    percentage: number;
    trend: 'up' | 'down' | 'stable';
  }>;
  severityBreakdown: Array<{
    severity: ErrorSeverity;
    count: number;
    percentage: number;
  }>;
  recentActivity: Array<{
    id: string;
    type: 'new_error' | 'resolved' | 'assigned';
    message: string;
    timestamp: Date;
    user?: string;
  }>;
}

interface SerializedErrorReport extends Record<string, unknown> {
  id: string;
  timestamp: string;
  message: string;
  category: ErrorCategory;
  severity: ErrorSeverity;
  resolved: boolean;
  tags: string[];
  similarErrors: number;
  impact: {
    usersAffected: number;
    requestsAffected: number;
    downtimeMinutes?: number;
  };
  statusCode?: number;
  code?: string;
  stack?: string;
  resolvedAt?: string;
  resolvedBy?: string;
  resolutionNotes?: string;
  assignee?: string;
}

interface SerializedErrorContext extends Record<string, unknown> {
  requestId: string;
  ip: string;
  userAgent: string;
  method: string;
  url: string;
  timestamp: string;
  duration: number;
  userId?: string;
  body?: Prisma.InputJsonValue;
  query?: Prisma.InputJsonValue;
  params?: Prisma.InputJsonValue;
}

interface ErrorAuditLogPayload {
  error: SerializedErrorReport;
  context: SerializedErrorContext;
}

type JsonRecord = Record<string, unknown>;

const ERROR_ACTION = 'ERROR_REPORT';

export class ErrorReportingService {
  private prisma: PrismaClient;

  private alertThresholds = {
    criticalErrorsPerHour: 5,
    errorRateThreshold: 0.05,
    duplicateErrorThreshold: 10,
  };

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createErrorReport(
    error: BaseError,
    context: ErrorContextData,
  ): Promise<ErrorReport> {
    try {
      const errorId = `err_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
      const { category, severity } = categorizeError(error);
      const similarErrors = await this.findSimilarErrors(
        error.message,
        category,
      );
      const report: ErrorReport = {
        id: errorId,
        timestamp: context.timestamp,
        message: error.message,
        category,
        severity,
        context,
        resolved: false,
        tags: this.generateErrorTags(error, context, category, severity),
        similarErrors: similarErrors.length,
        impact: await this.calculateErrorImpact(category),
      };

      if (error.statusCode !== undefined) {
        report.statusCode = error.statusCode;
      }
      if (error.code !== undefined) {
        report.code = error.code;
      }
      if (error.stack !== undefined) {
        report.stack = error.stack;
      }

      await this.prisma.audit_logs.create({
        data: {
          id: randomUUID(),
          entity: 'ERROR',
          action: ERROR_ACTION,
          entity_id: report.id,
          performed_by: context.userId ?? 'SYSTEM',
          ip_address: context.ip || null,
          user_agent: context.userAgent || null,
          new_values: this.createAuditPayload(report, context),
        },
      });

      await this.checkAlertConditions(report);

      logger.info('Error report created', {
        errorId: report.id,
        category: report.category,
        severity: report.severity,
      });

      return report;
    } catch (reportingError) {
      logger.error('Failed to create error report', { error: reportingError });
      throw new Error(
        `Error reporting failed: ${(reportingError as Error).message}`,
      );
    }
  }

  async getErrorReports(
    filter: ErrorReportFilter = {},
  ): Promise<ErrorReport[]> {
    try {
      const conditions: Prisma.audit_logsWhereInput[] = [
        { action: ERROR_ACTION },
      ];

      if (filter.startDate || filter.endDate) {
        const createdAt: Prisma.DateTimeFilter = {};
        if (filter.startDate) {
          createdAt.gte = filter.startDate;
        }
        if (filter.endDate) {
          createdAt.lte = filter.endDate;
        }
        conditions.push({ created_at: createdAt });
      }

      if (filter.category) {
        conditions.push({
          new_values: this.jsonEquals(['error', 'category'], filter.category),
        });
      }

      if (filter.severity) {
        conditions.push({
          new_values: this.jsonEquals(['error', 'severity'], filter.severity),
        });
      }

      if (filter.resolved !== undefined) {
        conditions.push({
          new_values: this.jsonEquals(['error', 'resolved'], filter.resolved),
        });
      }

      if (filter.search) {
        conditions.push({
          new_values: this.jsonContains(['error', 'message'], filter.search),
        });
      }

      const where: Prisma.audit_logsWhereInput =
        conditions.length > 1
          ? { AND: conditions }
          : (conditions[0] ?? { action: ERROR_ACTION });

      const logs = await this.prisma.audit_logs.findMany({
        where,
        orderBy: { created_at: 'desc' },
        take: 1000,
      });

      return logs
        .map(log => this.parseAuditLog(log))
        .filter((report): report is ErrorReport => report !== null)
        .filter(report => {
          if (filter.assignee && report.assignee !== filter.assignee) {
            return false;
          }
          if (
            filter.tags &&
            !filter.tags.some(tag => report.tags.includes(tag))
          ) {
            return false;
          }
          return true;
        });
    } catch (error) {
      logger.error('Failed to get error reports', { error });
      throw new Error('Failed to retrieve error reports');
    }
  }

  async getErrorDashboard(
    timeframe: '1h' | '24h' | '7d' | '30d' = '24h',
  ): Promise<ErrorDashboard> {
    try {
      const now = new Date();
      const startDate = this.getStartDateFromTimeframe(timeframe, now);
      const reports = await this.getErrorReports({ startDate, endDate: now });

      const metrics = getErrorMetrics();
      const trends = getErrorTrends();

      return {
        overview: {
          totalErrors: metrics.totalErrors,
          unresolvedErrors: reports.filter(r => !r.resolved).length,
          criticalErrors: reports.filter(
            r => r.severity === ErrorSeverity.CRITICAL,
          ).length,
          errorsLast24h: this.getErrorsInLastHours(reports, 24),
          errorRate: this.calculateErrorRate(metrics),
          uptime: this.calculateUptime(reports, timeframe),
        },
        trends: this.generateTrendData(reports, timeframe),
        topErrors: this.getTopErrors(reports),
        categoryBreakdown: trends.categoryBreakdown.map(cat => ({
          ...cat,
          trend: this.calculateTrend(cat.category, reports),
        })),
        severityBreakdown: trends.severityBreakdown,
        recentActivity: await this.getRecentActivity(startDate, now),
      };
    } catch (error) {
      logger.error('Failed to generate error dashboard', { error });
      throw new Error('Failed to generate error dashboard');
    }
  }

  async resolveError(
    errorId: string,
    resolvedBy: string,
    resolutionNotes?: string,
  ): Promise<void> {
    try {
      const log = await this.prisma.audit_logs.findFirst({
        where: {
          action: ERROR_ACTION,
          new_values: this.jsonEquals(['error', 'id'], errorId),
        },
      });

      if (!log) {
        throw new Error(`Error report ${errorId} not found`);
      }

      const payload = this.extractAuditPayload(log);
      if (!payload) {
        throw new Error('Stored error payload is invalid');
      }

      const report = this.deserializeReport(payload);
      report.resolved = true;
      report.resolvedAt = new Date();
      report.resolvedBy = resolvedBy;
      if (resolutionNotes !== undefined) {
        report.resolutionNotes = resolutionNotes;
      }

      await this.prisma.audit_logs.update({
        where: { id: log.id },
        data: {
          new_values: this.createAuditPayload(
            report,
            this.deserializeContext(payload.context),
          ),
        },
      });

      await this.prisma.audit_logs.create({
        data: {
          id: randomUUID(),
          entity: 'ERROR',
          action: 'ERROR_RESOLVED',
          entity_id: errorId,
          performed_by: resolvedBy,
          new_values: {
            errorId,
            resolutionNotes,
            resolvedAt: new Date().toISOString(),
          },
        },
      });

      logger.info('Error resolved', { errorId, resolvedBy });
    } catch (error) {
      logger.error('Failed to resolve error', { errorId, error });
      throw new Error('Failed to resolve error');
    }
  }

  async assignError(errorId: string, assignee: string): Promise<void> {
    try {
      const log = await this.prisma.audit_logs.findFirst({
        where: {
          action: ERROR_ACTION,
          new_values: this.jsonEquals(['error', 'id'], errorId),
        },
      });

      if (!log) {
        throw new Error(`Error report ${errorId} not found`);
      }

      const payload = this.extractAuditPayload(log);
      if (!payload) {
        throw new Error('Stored error payload is invalid');
      }

      const report = this.deserializeReport(payload);
      report.assignee = assignee;

      await this.prisma.audit_logs.update({
        where: { id: log.id },
        data: {
          new_values: this.createAuditPayload(
            report,
            this.deserializeContext(payload.context),
          ),
        },
      });

      await this.prisma.audit_logs.create({
        data: {
          id: randomUUID(),
          entity: 'ERROR',
          action: 'ERROR_ASSIGNED',
          entity_id: errorId,
          performed_by: assignee,
          new_values: {
            errorId,
            assignee,
            assignedAt: new Date().toISOString(),
          },
        },
      });

      logger.info('Error assigned', { errorId, assignee });
    } catch (error) {
      logger.error('Failed to assign error', { errorId, error });
      throw new Error('Failed to assign error');
    }
  }

  async exportErrorReports(
    filter: ErrorReportFilter = {},
    format: 'json' | 'csv' = 'json',
  ): Promise<string> {
    try {
      const reports = await this.getErrorReports(filter);
      if (format === 'csv') {
        return this.convertToCSV(reports);
      }
      return JSON.stringify(reports, null, 2);
    } catch (error) {
      logger.error('Failed to export error reports', { error });
      throw new Error('Failed to export error reports');
    }
  }

  async getErrorMetrics(): Promise<ReturnType<typeof getErrorMetrics>> {
    return getErrorMetrics();
  }

  async getErrorTrends(): Promise<ReturnType<typeof getErrorTrends>> {
    return getErrorTrends();
  }

  private async findSimilarErrors(
    message: string,
    category: ErrorCategory,
  ): Promise<ErrorReport[]> {
    try {
      const windowStart = new Date(Date.now() - 24 * 60 * 60 * 1000);
      const logs = await this.prisma.audit_logs.findMany({
        where: {
          action: ERROR_ACTION,
          created_at: { gte: windowStart },
          new_values: this.jsonEquals(['error', 'category'], category),
        },
        orderBy: { created_at: 'desc' },
        take: 100,
      });

      const reports = logs
        .map(log => this.parseAuditLog(log))
        .filter((report): report is ErrorReport => report !== null);

      return reports.filter(report =>
        this.areMessagesSimilar(report.message, message),
      );
    } catch (error) {
      logger.error('Failed to find similar errors', { error });
      return [];
    }
  }

  private areMessagesSimilar(a: string, b: string): boolean {
    const normalize = (value: string): string[] =>
      value.toLowerCase().split(/\W+/).filter(Boolean);

    const wordsA = new Set(normalize(a));
    const wordsB = new Set(normalize(b));

    let matches = 0;
    wordsA.forEach(word => {
      if (wordsB.has(word)) {
        matches += 1;
      }
    });

    return matches >= 2;
  }

  private generateErrorTags(
    error: BaseError,
    context: ErrorContextData,
    category: ErrorCategory,
    severity: ErrorSeverity,
  ): string[] {
    const tags: string[] = [];
    tags.push(category.toLowerCase());
    tags.push(severity.toLowerCase());

    if (context.method) {
      tags.push(`method:${context.method.toLowerCase()}`);
    }

    if (context.url) {
      const segments = context.url.split('/').filter(Boolean);
      const firstSegment = segments[0];
      if (firstSegment) {
        tags.push(`endpoint:${firstSegment.toLowerCase()}`);
      }
    }

    if (typeof error.statusCode === 'number') {
      tags.push(`status:${error.statusCode}`);
    }

    if (typeof error.code === 'string' && error.code.length > 0) {
      tags.push(`code:${error.code.toLowerCase()}`);
    }

    if (context.userAgent) {
      const agent = context.userAgent;
      if (agent.includes('Chrome')) tags.push('browser:chrome');
      if (agent.includes('Firefox')) tags.push('browser:firefox');
      if (agent.includes('Mobile')) tags.push('client:mobile');
    }

    return Array.from(new Set(tags));
  }

  private async calculateErrorImpact(category: ErrorCategory): Promise<{
    usersAffected: number;
    requestsAffected: number;
    downtimeMinutes?: number;
  }> {
    try {
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      const logs = await this.prisma.audit_logs.findMany({
        where: {
          action: ERROR_ACTION,
          created_at: { gte: oneHourAgo },
          new_values: this.jsonEquals(['error', 'category'], category),
        },
      });

      const contexts = logs
        .map(log => this.extractAuditPayload(log))
        .filter((payload): payload is ErrorAuditLogPayload => payload !== null)
        .map(payload => payload.context);

      const uniqueUsers = new Set(
        contexts
          .map(ctx => ctx.userId)
          .filter(
            (userId): userId is string =>
              typeof userId === 'string' && userId.length > 0,
          ),
      );

      return {
        usersAffected: uniqueUsers.size,
        requestsAffected: logs.length,
      };
    } catch (error) {
      logger.error('Failed to calculate error impact', { error });
      return {
        usersAffected: 1,
        requestsAffected: 1,
      };
    }
  }

  private async checkAlertConditions(report: ErrorReport): Promise<void> {
    if (report.severity === ErrorSeverity.CRITICAL) {
      const recentCriticalErrors = await this.getErrorsInLastHoursBySeverity(
        ErrorSeverity.CRITICAL,
        1,
      );
      if (recentCriticalErrors >= this.alertThresholds.criticalErrorsPerHour) {
        await this.sendAlert('CRITICAL_ERROR_THRESHOLD', {
          count: recentCriticalErrors,
          threshold: this.alertThresholds.criticalErrorsPerHour,
        });
      }
    }

    if (report.similarErrors >= this.alertThresholds.duplicateErrorThreshold) {
      await this.sendAlert('DUPLICATE_ERROR_THRESHOLD', {
        message: report.message,
        count: report.similarErrors,
      });
    }
  }

  private async sendAlert(type: string, data: JsonRecord): Promise<void> {
    try {
      logger.warn('Error alert triggered', { type, data });
    } catch (error) {
      logger.error('Failed to send error alert', { type, error });
    }
  }

  private getStartDateFromTimeframe(timeframe: string, now: Date): Date {
    const timeframes: Record<'1h' | '24h' | '7d' | '30d', number> = {
      '1h': 1 * 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000,
      '7d': 7 * 24 * 60 * 60 * 1000,
      '30d': 30 * 24 * 60 * 60 * 1000,
    };

    return new Date(
      now.getTime() - timeframes[timeframe as keyof typeof timeframes],
    );
  }

  private getErrorsInLastHours(reports: ErrorReport[], hours: number): number {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    return reports.filter(r => r.timestamp >= cutoff).length;
  }

  private async getErrorsInLastHoursBySeverity(
    severity: ErrorSeverity,
    hours: number,
  ): Promise<number> {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    const logs = await this.prisma.audit_logs.findMany({
      where: {
        action: ERROR_ACTION,
        created_at: { gte: cutoff },
        new_values: this.jsonEquals(['error', 'severity'], severity),
      },
    });

    return logs.length;
  }

  private calculateErrorRate(
    metrics: ReturnType<typeof getErrorMetrics>,
  ): number {
    return metrics.totalErrors > 0
      ? Math.min(metrics.totalErrors / 1000, 1)
      : 0;
  }

  private calculateUptime(reports: ErrorReport[], timeframe: string): number {
    const totalMinutes: Record<'1h' | '24h' | '7d' | '30d', number> = {
      '1h': 60,
      '24h': 24 * 60,
      '7d': 7 * 24 * 60,
      '30d': 30 * 24 * 60,
    };

    const criticalErrors = reports.filter(
      r => r.severity === ErrorSeverity.CRITICAL,
    );
    const downtimeMinutes = criticalErrors.length * 5;

    const total = totalMinutes[timeframe as keyof typeof totalMinutes];
    const uptime =
      total > 0 ? Math.max(0, (total - downtimeMinutes) / total) : 1;

    return Math.round(uptime * 100);
  }

  private generateTrendData(
    reports: ErrorReport[],
    timeframe: string,
  ): ErrorTrend[] {
    const trends: ErrorTrend[] = [];
    const startDate = this.getStartDateFromTimeframe(timeframe, new Date());
    const isHourly = timeframe === '1h' || timeframe === '24h';
    const interval = isHourly ? 60 * 60 * 1000 : 24 * 60 * 60 * 1000;

    for (let date = startDate.getTime(); date < Date.now(); date += interval) {
      const periodStart = new Date(date);
      const periodEnd = new Date(date + interval);

      const periodReports = reports.filter(
        r => r.timestamp >= periodStart && r.timestamp < periodEnd,
      );

      trends.push({
        date: periodStart.toISOString(),
        total: periodReports.length,
        critical: periodReports.filter(
          r => r.severity === ErrorSeverity.CRITICAL,
        ).length,
        high: periodReports.filter(r => r.severity === ErrorSeverity.HIGH)
          .length,
        medium: periodReports.filter(r => r.severity === ErrorSeverity.MEDIUM)
          .length,
        low: periodReports.filter(r => r.severity === ErrorSeverity.LOW).length,
        categories: this.getCategoryCounts(periodReports),
      });
    }

    return trends;
  }

  private getCategoryCounts(
    reports: ErrorReport[],
  ): Record<ErrorCategory, number> {
    const counts = Object.values(ErrorCategory).reduce<
      Record<ErrorCategory, number>
    >(
      (acc, category) => {
        acc[category] = 0;
        return acc;
      },
      {} as Record<ErrorCategory, number>,
    );

    reports.forEach(report => {
      counts[report.category] = (counts[report.category] || 0) + 1;
    });

    return counts;
  }

  private getTopErrors(reports: ErrorReport[]): Array<{
    id: string;
    message: string;
    count: number;
    severity: ErrorSeverity;
    lastOccurred: Date;
  }> {
    const errorGroups = reports.reduce<
      Record<
        string,
        {
          id: string;
          message: string;
          count: number;
          severity: ErrorSeverity;
          lastOccurred: Date;
        }
      >
    >((groups, report) => {
      const key = report.message;
      if (!groups[key]) {
        groups[key] = {
          id: report.id,
          message: report.message,
          count: 0,
          severity: report.severity,
          lastOccurred: report.timestamp,
        };
      }
      groups[key].count += 1;
      if (report.timestamp > groups[key].lastOccurred) {
        groups[key].lastOccurred = report.timestamp;
      }
      return groups;
    }, {});

    return Object.values(errorGroups)
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }

  private calculateTrend(
    category: ErrorCategory,
    reports: ErrorReport[],
  ): 'up' | 'down' | 'stable' {
    const now = new Date();
    const midPoint = new Date(now.getTime() - 12 * 60 * 60 * 1000);

    const recent = reports.filter(
      r => r.timestamp >= midPoint && r.category === category,
    );
    const older = reports.filter(
      r => r.timestamp < midPoint && r.category === category,
    );

    if (recent.length > older.length * 1.2) return 'up';
    if (recent.length < older.length * 0.8) return 'down';
    return 'stable';
  }

  private async getRecentActivity(
    startDate: Date,
    endDate: Date,
  ): Promise<ErrorDashboard['recentActivity']> {
    try {
      const logs = await this.prisma.audit_logs.findMany({
        where: {
          action: { in: [ERROR_ACTION, 'ERROR_RESOLVED', 'ERROR_ASSIGNED'] },
          created_at: { gte: startDate, lte: endDate },
        },
        orderBy: { created_at: 'desc' },
        take: 50,
      });

      const activity: ErrorDashboard['recentActivity'] = [];

      for (const log of logs) {
        if (log.action === ERROR_ACTION) {
          const payload = this.extractAuditPayload(log);
          const message = payload?.error?.message ?? 'Unknown error';
          const entry: ErrorDashboard['recentActivity'][number] = {
            id: log.id,
            type: 'new_error',
            message: `New error: ${message}`,
            timestamp: log.created_at,
          };
          const userId = payload?.context.userId;
          if (userId) {
            entry.user = userId;
          }
          activity.push(entry);
          continue;
        }

        if (log.action === 'ERROR_RESOLVED') {
          const payload = this.toJsonRecord(log.new_values);
          const entry: ErrorDashboard['recentActivity'][number] = {
            id: log.id,
            type: 'resolved',
            message: `Error resolved: ${payload?.errorId ?? 'unknown'}`,
            timestamp: log.created_at,
          };
          if (log.performed_by) {
            entry.user = log.performed_by;
          }
          activity.push(entry);
          continue;
        }

        if (log.action === 'ERROR_ASSIGNED') {
          const payload = this.toJsonRecord(log.new_values);
          const entry: ErrorDashboard['recentActivity'][number] = {
            id: log.id,
            type: 'assigned',
            message: `Error assigned: ${payload?.errorId ?? 'unknown'}`,
            timestamp: log.created_at,
          };
          if (log.performed_by) {
            entry.user = log.performed_by;
          }
          activity.push(entry);
        }
      }

      return activity;
    } catch (error) {
      logger.error('Failed to get recent activity', { error });
      return [];
    }
  }

  private convertToCSV(reports: ErrorReport[]): string {
    const headers = [
      'ID',
      'Timestamp',
      'Message',
      'Category',
      'Severity',
      'Status',
      'Endpoint',
      'User ID',
      'Assignee',
      'Similar Errors',
    ];

    const rows = reports.map(report => [
      report.id,
      report.timestamp.toISOString(),
      `"${report.message.replace(/"/g, '""')}"`,
      report.category,
      report.severity,
      report.resolved ? 'Resolved' : 'Open',
      report.context.url,
      report.context.userId ?? '',
      report.assignee ?? '',
      report.similarErrors.toString(),
    ]);

    return [headers, ...rows].map(row => row.join(',')).join('\n');
  }

  private createAuditPayload(
    report: ErrorReport,
    context: ErrorContextData,
  ): Prisma.InputJsonValue {
    const payload: ErrorAuditLogPayload = {
      error: this.serializeReport(report),
      context: this.serializeContext(context),
    };

    return this.toInputJson(payload);
  }

  private serializeReport(report: ErrorReport): SerializedErrorReport {
    const serialized: SerializedErrorReport = {
      id: report.id,
      timestamp: report.timestamp.toISOString(),
      message: report.message,
      category: report.category,
      severity: report.severity,
      resolved: report.resolved,
      tags: report.tags,
      similarErrors: report.similarErrors,
      impact: {
        usersAffected: report.impact.usersAffected,
        requestsAffected: report.impact.requestsAffected,
      },
    };

    if (report.impact.downtimeMinutes !== undefined) {
      serialized.impact.downtimeMinutes = report.impact.downtimeMinutes;
    }
    if (report.statusCode !== undefined) {
      serialized.statusCode = report.statusCode;
    }
    if (report.code !== undefined) {
      serialized.code = report.code;
    }
    if (report.stack !== undefined) {
      serialized.stack = report.stack;
    }
    if (report.resolvedAt) {
      serialized.resolvedAt = report.resolvedAt.toISOString();
    }
    if (report.resolvedBy !== undefined) {
      serialized.resolvedBy = report.resolvedBy;
    }
    if (report.resolutionNotes !== undefined) {
      serialized.resolutionNotes = report.resolutionNotes;
    }
    if (report.assignee !== undefined) {
      serialized.assignee = report.assignee;
    }

    return serialized;
  }

  private serializeContext(context: ErrorContextData): SerializedErrorContext {
    const serialized: SerializedErrorContext = {
      requestId: context.requestId,
      ip: context.ip,
      userAgent: context.userAgent,
      method: context.method,
      url: context.url,
      timestamp: context.timestamp.toISOString(),
      duration: context.duration,
    };

    if (context.userId) {
      serialized.userId = context.userId;
    }

    const bodyJson = this.sanitizeJson(context.body);
    if (bodyJson !== null) {
      serialized.body = bodyJson;
    }

    const queryJson = this.sanitizeJson(context.query);
    if (queryJson !== null) {
      serialized.query = queryJson;
    }

    const paramsJson = this.sanitizeJson(context.params);
    if (paramsJson !== null) {
      serialized.params = paramsJson;
    }

    return serialized;
  }

  private parseAuditLog(log: AuditLogModel): ErrorReport | null {
    const payload = this.extractAuditPayload(log);
    if (!payload) {
      return null;
    }

    return this.deserializeReport(payload);
  }

  private extractAuditPayload(log: AuditLogModel): ErrorAuditLogPayload | null {
    if (!this.isRecord(log.new_values)) {
      return null;
    }

    const errorValue = (log.new_values as JsonRecord).error;
    const contextValue = (log.new_values as JsonRecord).context;

    if (!this.isRecord(errorValue) || !this.isRecord(contextValue)) {
      return null;
    }

    const errorRecord = errorValue as JsonRecord;
    const contextRecord = contextValue as JsonRecord;

    if (
      !this.isSerializedErrorReport(errorRecord) ||
      !this.isSerializedErrorContext(contextRecord)
    ) {
      return null;
    }

    return {
      error: errorRecord,
      context: contextRecord,
    };
  }

  private deserializeReport(payload: ErrorAuditLogPayload): ErrorReport {
    const context = this.deserializeContext(payload.context);
    const report: ErrorReport = {
      id: payload.error.id,
      timestamp: new Date(payload.error.timestamp),
      message: payload.error.message,
      category: payload.error.category,
      severity: payload.error.severity,
      context,
      resolved: payload.error.resolved,
      tags: payload.error.tags,
      similarErrors: payload.error.similarErrors,
      impact: {
        usersAffected: payload.error.impact.usersAffected,
        requestsAffected: payload.error.impact.requestsAffected,
      },
    };

    if (payload.error.impact.downtimeMinutes !== undefined) {
      report.impact.downtimeMinutes = payload.error.impact.downtimeMinutes;
    }
    if (payload.error.statusCode !== undefined) {
      report.statusCode = payload.error.statusCode;
    }
    if (payload.error.code !== undefined) {
      report.code = payload.error.code;
    }
    if (payload.error.stack !== undefined) {
      report.stack = payload.error.stack;
    }
    if (payload.error.resolvedAt) {
      report.resolvedAt = new Date(payload.error.resolvedAt);
    }
    if (payload.error.resolvedBy !== undefined) {
      report.resolvedBy = payload.error.resolvedBy;
    }
    if (payload.error.resolutionNotes !== undefined) {
      report.resolutionNotes = payload.error.resolutionNotes;
    }
    if (payload.error.assignee !== undefined) {
      report.assignee = payload.error.assignee;
    }

    return report;
  }

  private deserializeContext(
    context: SerializedErrorContext,
  ): ErrorContextData {
    const result: ErrorContextData = {
      requestId: context.requestId,
      ip: context.ip,
      userAgent: context.userAgent,
      method: context.method,
      url: context.url,
      timestamp: new Date(context.timestamp),
      duration: context.duration,
    };

    if (context.userId) {
      result.userId = context.userId;
    }
    if (context.body !== undefined) {
      result.body = context.body;
    }
    if (context.query !== undefined) {
      result.query = context.query;
    }
    if (context.params !== undefined) {
      result.params = context.params;
    }

    return result;
  }

  private sanitizeJson(value: unknown): Prisma.InputJsonValue | null {
    if (value === undefined || value === null) {
      return null;
    }

    try {
      return this.toInputJson(value);
    } catch (error) {
      logger.debug('Failed to sanitize JSON value, falling back to string', {
        value,
        error,
      });
      return String(value) as Prisma.InputJsonValue;
    }
  }

  private isRecord(value: unknown): value is JsonRecord {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
  }

  private isSerializedErrorReport(
    value: JsonRecord,
  ): value is SerializedErrorReport {
    if (
      typeof value.id !== 'string' ||
      typeof value.timestamp !== 'string' ||
      typeof value.message !== 'string' ||
      typeof value.category !== 'string' ||
      typeof value.severity !== 'string' ||
      typeof value.resolved !== 'boolean' ||
      !Array.isArray(value.tags) ||
      typeof value.similarErrors !== 'number' ||
      !this.isRecord(value.impact)
    ) {
      return false;
    }

    if (
      !Object.values(ErrorCategory).includes(value.category as ErrorCategory)
    ) {
      return false;
    }

    if (
      !Object.values(ErrorSeverity).includes(value.severity as ErrorSeverity)
    ) {
      return false;
    }

    const impact = value.impact as JsonRecord;
    if (
      typeof impact.usersAffected !== 'number' ||
      typeof impact.requestsAffected !== 'number'
    ) {
      return false;
    }

    if (
      impact.downtimeMinutes !== undefined &&
      typeof impact.downtimeMinutes !== 'number'
    ) {
      return false;
    }

    if (
      value.statusCode !== undefined &&
      typeof value.statusCode !== 'number'
    ) {
      return false;
    }

    if (value.code !== undefined && typeof value.code !== 'string') {
      return false;
    }

    if (value.stack !== undefined && typeof value.stack !== 'string') {
      return false;
    }

    if (
      value.resolvedAt !== undefined &&
      typeof value.resolvedAt !== 'string'
    ) {
      return false;
    }

    if (
      value.resolvedBy !== undefined &&
      typeof value.resolvedBy !== 'string'
    ) {
      return false;
    }

    if (
      value.resolutionNotes !== undefined &&
      typeof value.resolutionNotes !== 'string'
    ) {
      return false;
    }

    if (value.assignee !== undefined && typeof value.assignee !== 'string') {
      return false;
    }

    return true;
  }

  private isSerializedErrorContext(
    value: JsonRecord,
  ): value is SerializedErrorContext {
    if (
      typeof value.requestId !== 'string' ||
      typeof value.ip !== 'string' ||
      typeof value.userAgent !== 'string' ||
      typeof value.method !== 'string' ||
      typeof value.url !== 'string' ||
      typeof value.timestamp !== 'string' ||
      typeof value.duration !== 'number'
    ) {
      return false;
    }

    if (value.userId !== undefined && typeof value.userId !== 'string') {
      return false;
    }

    return true;
  }

  private toJsonRecord(
    value: Prisma.JsonValue | null | undefined,
  ): JsonRecord | null {
    if (this.isRecord(value)) {
      return value as JsonRecord;
    }
    return null;
  }

  private jsonPath(...segments: string[]): string {
    return `$.${segments.join('.')}`;
  }

  private jsonEquals(segments: string[], value: unknown): Prisma.JsonFilter {
    return {
      path: this.jsonPath(...segments),
      equals: this.toInputJson(value),
    };
  }

  private jsonContains(segments: string[], search: string): Prisma.JsonFilter {
    return {
      path: this.jsonPath(...segments),
      string_contains: search,
    };
  }

  private toInputJson(value: unknown): Prisma.InputJsonValue {
    try {
      return JSON.parse(JSON.stringify(value)) as Prisma.InputJsonValue;
    } catch (error) {
      logger.debug('Failed to convert value to JSON input', { value, error });
      return String(value) as Prisma.InputJsonValue;
    }
  }
}

export const errorReportingService = new ErrorReportingService();
